package uitgo.driverservice.integration;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;
import org.springframework.transaction.annotation.Transactional;
import uitgo.driverservice.dto.DriverLocationDTO;
import uitgo.driverservice.dto.DriverStatusUpdateDTO;
import uitgo.driverservice.entity.Driver;
import uitgo.driverservice.entity.DriverLocation;
import uitgo.driverservice.entity.Driver.DriverStatus;
import uitgo.driverservice.exception.DriverServiceException;
import uitgo.driverservice.repository.DriverRepository;
import uitgo.driverservice.repository.DriverLocationRepository;
import uitgo.driverservice.service.DriverLocationService;
import uitgo.driverservice.service.DriverStatusService;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@TestPropertySource(locations = "classpath:application-test.yml")
@Transactional
@DisplayName("Driver Service Integration Tests")
class DriverServiceIntegrationTest {

    @Autowired
    private DriverRepository driverRepository;

    @Autowired
    private DriverLocationRepository driverLocationRepository;

    @Autowired
    private DriverLocationService driverLocationService;

    @Autowired
    private DriverStatusService driverStatusService;

    private Driver testDriver;
    private UUID testDriverId;
    private UUID testUserId;

    @BeforeEach
    void setUp() {
        // Clean up existing data
        driverLocationRepository.deleteAll();
        driverRepository.deleteAll();

        // Create test data
        testUserId = UUID.randomUUID();
        testDriver = Driver.builder()
                .userId(testUserId)
                .licenseNumber("TEST-" + System.currentTimeMillis())
                .vehicleModel("Toyota Camry Test")
                .vehiclePlate("TEST-123")
                .rating(4.5)
                .totalCompletedTrips(0)
                .status(DriverStatus.AVAILABLE)
                .vehicleCapacity(4)
                .createdAt(System.currentTimeMillis())
                .updatedAt(System.currentTimeMillis())
                .build();

        testDriver = driverRepository.save(testDriver);
        testDriverId = testDriver.getDriverId();
    }

    @Test
    @DisplayName("Should create and save driver successfully")
    void shouldCreateAndSaveDriverSuccessfully() {
        // Then
        assertNotNull(testDriver.getDriverId());
        assertEquals(testUserId, testDriver.getUserId());
        assertEquals("Toyota Camry Test", testDriver.getVehicleModel());
        assertEquals(DriverStatus.AVAILABLE, testDriver.getStatus());

        // Verify it's persisted
        Optional<Driver> foundDriver = driverRepository.findById(testDriverId);
        assertTrue(foundDriver.isPresent());
        assertEquals(testDriver.getLicenseNumber(), foundDriver.get().getLicenseNumber());
    }

    @Test
    @DisplayName("Should update driver location and persist to database")
    void shouldUpdateDriverLocationAndPersistToDatabase() {
        // Given
        Double latitude = 10.7769; // Ho Chi Minh City
        Double longitude = 106.7009;

        // When
        DriverLocationDTO result = driverLocationService.updateDriverLocation(testDriverId, latitude, longitude);

        // Then
        assertNotNull(result);
        assertEquals(testDriverId, result.getDriverId());
        assertEquals(latitude, result.getLatitude());
        assertEquals(longitude, result.getLongitude());
        assertNotNull(result.getTimestamp());

        // Verify it's persisted in database
        List<DriverLocation> locations = driverLocationRepository.findRecentLocationsByDriverId(testDriverId, 10);
        assertFalse(locations.isEmpty());
        
        DriverLocation savedLocation = locations.get(0);
        assertEquals(testDriverId, savedLocation.getDriverId());
        assertEquals(latitude, savedLocation.getLatitude());
        assertEquals(longitude, savedLocation.getLongitude());
        // Note: geohash is not currently generated by the entity
    }

    @Test
    @DisplayName("Should update driver status and persist to database")
    void shouldUpdateDriverStatusAndPersistToDatabase() {
        // Given
        String newStatus = "BUSY";

        // When
        DriverStatusUpdateDTO result = driverStatusService.updateDriverStatus(testDriverId, newStatus);

        // Then
        assertNotNull(result);
        assertEquals(testDriverId, result.getDriverId());
        assertEquals(newStatus, result.getStatus());
        assertTrue(result.getSuccess());

        // Verify it's persisted in database
        Optional<Driver> updatedDriver = driverRepository.findById(testDriverId);
        assertTrue(updatedDriver.isPresent());
        assertEquals(DriverStatus.BUSY, updatedDriver.get().getStatus());
        assertNotNull(updatedDriver.get().getUpdatedAt());
    }

    @Test
    @DisplayName("Should handle multiple location updates for same driver")
    void shouldHandleMultipleLocationUpdatesForSameDriver() {
        // Given - Multiple locations in Ho Chi Minh City
        Double[][] locations = {
                {10.7769, 106.7009}, // District 1
                {10.7829, 106.6934}, // District 3
                {10.7756, 106.7019}, // Near District 1
                {10.7851, 106.6917}  // District 10
        };

        // When
        for (Double[] location : locations) {
            driverLocationService.updateDriverLocation(testDriverId, location[0], location[1]);
            
            // Add small delay to ensure different timestamps
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // Then
        List<DriverLocation> savedLocations = driverLocationRepository
                .findRecentLocationsByDriverId(testDriverId, 10);
        
        assertEquals(4, savedLocations.size());
        
        // Verify they are ordered by timestamp (most recent first)
        for (int i = 0; i < savedLocations.size() - 1; i++) {
            assertTrue(savedLocations.get(i).getTimestamp() >= savedLocations.get(i + 1).getTimestamp());
        }

        // Verify the most recent location is the last one we updated
        DriverLocation mostRecent = savedLocations.get(0);
        assertEquals(locations[3][0], mostRecent.getLatitude());
        assertEquals(locations[3][1], mostRecent.getLongitude());
    }

    @Test
    @DisplayName("Should handle status transitions correctly")
    void shouldHandleStatusTransitionsCorrectly() {
        // Test status transition flow: AVAILABLE -> BUSY -> ON_BREAK -> AVAILABLE -> OFFLINE
        String[] statusFlow = {"BUSY", "ON_BREAK", "AVAILABLE", "OFFLINE"};

        for (String status : statusFlow) {
            // When
            DriverStatusUpdateDTO result = driverStatusService.updateDriverStatus(testDriverId, status);

            // Then
            assertNotNull(result);
            assertTrue(result.getSuccess());
            assertEquals(status, result.getStatus());

            // Verify in database
            Optional<Driver> driver = driverRepository.findById(testDriverId);
            assertTrue(driver.isPresent());
            assertEquals(DriverStatus.valueOf(status), driver.get().getStatus());
        }
    }

    @Test
    @DisplayName("Should handle driver not found scenarios gracefully")
    void shouldHandleDriverNotFoundScenarios() {
        // Given
        UUID nonExistentDriverId = UUID.randomUUID();

        // When - Location update for non-existent driver (should succeed and create driver behavior)
        DriverLocationDTO locationResult = driverLocationService.updateDriverLocation(nonExistentDriverId, 10.7769, 106.7009);
        
        // Then - Should handle gracefully (not throw exception)
        assertNotNull(locationResult);
        assertEquals(nonExistentDriverId, locationResult.getDriverId());

        // When & Then - Status update for non-existent driver should throw exception
        assertThrows(DriverServiceException.class, () -> {
            driverStatusService.updateDriverStatus(nonExistentDriverId, "BUSY");
        });
    }

    @Test
    @DisplayName("Should handle invalid coordinates gracefully")
    void shouldHandleInvalidCoordinatesGracefully() {
        // Test with invalid coordinates
        Double[][] invalidCoordinates = {
                {100.0, 106.7009},   // Invalid latitude (> 90)
                {10.7769, 200.0},    // Invalid longitude (> 180)
                {-100.0, 106.7009},  // Invalid latitude (< -90)
                {10.7769, -200.0}    // Invalid longitude (< -180)
        };

        for (Double[] coords : invalidCoordinates) {
            // When & Then
            assertThrows(Exception.class, () -> {
                driverLocationService.updateDriverLocation(testDriverId, coords[0], coords[1]);
            });
        }
    }

    @Test
    @DisplayName("Should handle invalid status values gracefully")
    void shouldHandleInvalidStatusValuesGracefully() {
        // Test with invalid status values
        String[] invalidStatuses = {"INVALID_STATUS", "UNKNOWN", "", null, "driving", "working"};

        for (String status : invalidStatuses) {
            // When & Then
            assertThrows(Exception.class, () -> {
                driverStatusService.updateDriverStatus(testDriverId, status);
            });
        }
    }

    @Test
    @DisplayName("Should maintain data consistency across multiple operations")
    void shouldMaintainDataConsistencyAcrossMultipleOperations() {
        // Given - Perform multiple mixed operations
        UUID driver2Id = createSecondTestDriver();

        // When - Multiple concurrent-like operations
        driverLocationService.updateDriverLocation(testDriverId, 10.7769, 106.7009);
        driverLocationService.updateDriverLocation(driver2Id, 21.0285, 105.8542);
        driverStatusService.updateDriverStatus(testDriverId, "BUSY");
        driverLocationService.updateDriverLocation(testDriverId, 10.7829, 106.6934);
        driverStatusService.updateDriverStatus(driver2Id, "OFFLINE");

        // Then - Verify data consistency
        // Check driver 1
        Optional<Driver> driver1 = driverRepository.findById(testDriverId);
        assertTrue(driver1.isPresent());
        assertEquals(DriverStatus.BUSY, driver1.get().getStatus());

        List<DriverLocation> driver1Locations = driverLocationRepository
                .findRecentLocationsByDriverId(testDriverId, 10);
        assertEquals(2, driver1Locations.size());

        // Check driver 2
        Optional<Driver> driver2 = driverRepository.findById(driver2Id);
        assertTrue(driver2.isPresent());
        assertEquals(DriverStatus.OFFLINE, driver2.get().getStatus());

        List<DriverLocation> driver2Locations = driverLocationRepository
                .findRecentLocationsByDriverId(driver2Id, 10);
        assertEquals(1, driver2Locations.size());
    }

    @Test
    @DisplayName("Should handle database transaction rollback scenarios")
    void shouldHandleDatabaseTransactionRollbackScenarios() {
        // Given - Initial state
        long initialLocationCount = driverLocationRepository.count();
        
        // When - Try to update location with valid coordinates
        DriverLocationDTO result = driverLocationService.updateDriverLocation(testDriverId, 10.7769, 106.7009);
        
        // Then - Verify successful operation
        assertNotNull(result);
        assertEquals(initialLocationCount + 1, driverLocationRepository.count());

        // Verify the transaction was committed
        List<DriverLocation> locations = driverLocationRepository.findRecentLocationsByDriverId(testDriverId, 10);
        assertFalse(locations.isEmpty());
        assertEquals(testDriverId, locations.get(0).getDriverId());
    }

    private UUID createSecondTestDriver() {
        Driver driver2 = Driver.builder()
                .userId(UUID.randomUUID())
                .licenseNumber("TEST-2-" + System.currentTimeMillis())
                .vehicleModel("Honda Civic Test")
                .vehiclePlate("TEST-456")
                .rating(4.8)
                .totalCompletedTrips(5)
                .status(DriverStatus.AVAILABLE)
                .vehicleCapacity(4)
                .createdAt(System.currentTimeMillis())
                .updatedAt(System.currentTimeMillis())
                .build();

        return driverRepository.save(driver2).getDriverId();
    }
}